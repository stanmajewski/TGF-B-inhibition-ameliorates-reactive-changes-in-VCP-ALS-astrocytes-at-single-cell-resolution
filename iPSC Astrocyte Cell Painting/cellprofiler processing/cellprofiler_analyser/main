#!/usr/bin/env python3
"""
Main entry point for Enhanced Cell Profiler Data Analyser - Now with Z-score normalization options
"""

import sys
import argparse
from pathlib import Path
import datetime

# Add parent directory to path to allow imports from cellprofiler_analyser package
sys.path.insert(0, str(Path(__file__).parent.parent))

from cellprofiler_analyser.core.processor import EnhancedCellPaintingProcessor
from cellprofiler_analyser.core.visualization import DataVisualizer
from cellprofiler_analyser.utils.logging_utils import setup_logging

def run_replot_only(output_dir: str, use_pca: bool = True, verbose: bool = False) -> bool:
    """
    Run visualization replotting only using optimized coordinate-based approach
    UPDATED: Now includes hierarchical clustering
    
    Args:
        output_dir: Output directory containing existing coordinate files
        use_pca: Whether to use PCA model from analysis directory
        verbose: Enable verbose logging
        
    Returns:
        bool: Success status
    """
    # Setup logging
    log_level = 'DEBUG' if verbose else 'INFO'
    setup_logging(level=log_level)
    
    output_path = Path(output_dir)
    if not output_path.exists():
        print(f"ERROR: Output directory does not exist: {output_path}")
        return False
    
    # Check for coordinate file
    coords_dir = output_path / "visualizations" / "coordinates"
    coord_file = coords_dir / "embedding_coordinates.csv"
    
    if not coord_file.exists():
        print(f"ERROR: No coordinate file found: {coord_file}")
        print("Expected file:")
        print(f"  - {coord_file}")
        return False
    
    # Initialize visualizer
    visualizer = DataVisualizer(output_path)
    
    print(f"Found coordinate file: {coord_file}")
    print(f"Recreating UMAP/t-SNE plots and hierarchical clustering...")
    
    # Recreate plots using optimized coordinate-based approach (now includes clustering)
    success = visualizer.recreate_plots_from_coordinates(use_pca_from_analysis=use_pca)
    
    if success:
        print("Plot recreation completed successfully!")
        print(f"New optimized plots saved to: {output_path}/visualizations_redo/")
        print("Check the following directories:")
        print(f"  - UMAP plots: {output_path}/visualizations_redo/umap/")
        print(f"  - t-SNE plots: {output_path}/visualizations_redo/tsne/")
        print(f"  - Hierarchical clustering: {output_path}/hierarchical_clustering/")
        print("")
        print("KEY OPTIMIZATIONS APPLIED:")
        print("  - No legends displayed (major file size reduction)")
        print("  - Essential metadata hover only")
        print("  - Hierarchical clustering plots using Euclidean distance")
        print("  - Treatment-level aggregation for clustering")
    else:
        print("ERROR: Plot recreation failed!")
    
    return success


def main():
    """Main function that handles command line arguments"""
    
    parser = argparse.ArgumentParser(description='Enhanced Cell Profiler data processing with Z-score normalization')
    
    # Mode selection
    parser.add_argument('--mode', choices=['full', 'replot'], default='full',
                       help='Processing mode: full pipeline or replot visualizations only')
    
    # Full pipeline arguments
    parser.add_argument('--input', '-i', help='Input parquet file (required for full mode)')
    parser.add_argument('--metadata', '-m', help='Metadata CSV file (for full mode)')
    parser.add_argument('--config', '-c', help='Unified config YAML file (for full mode)')
    
    # Output directory with timestamping
    parser.add_argument('--output', '-o', help='Base output directory (timestamp will be added automatically)')
    parser.add_argument('--no-timestamp', action='store_true', 
                       help='Disable automatic timestamp in output directory name')
    
    # Optional threshold overrides (will override config file values if provided)
    parser.add_argument('--missing-threshold', type=float, help='Override missing threshold from config')
    parser.add_argument('--correlation-threshold', type=float, help='Override correlation threshold from config')
    parser.add_argument('--high-var-threshold', type=float, help='Override high variability threshold from config')
    parser.add_argument('--low-var-threshold', type=float, help='Override low variability threshold from config')
    
    # NEW: Normalization method options
    parser.add_argument('--normalization-baseline', choices=['dmso', 'all-conditions'], default=None,
                       help='Z-score normalization baseline: "dmso" (DMSO controls) or "all-conditions" (all treatments)')
    
    # Replot mode arguments
    parser.add_argument('--no-pca', action='store_true',
                       help='Do not load PCA model from analysis directory (replot mode)')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Enable verbose logging')
    # Landmark analysis
    parser.add_argument('--run-landmark-analysis', action='store_true',
                   help='Run landmark analysis after main pipeline (requires plate_definitions in config)')
    
    # Hierachical clustering
    parser.add_argument('--run-hierarchical-clustering', action='store_true',
                    help='Run hierarchical clustering analysis after main pipeline (requires landmark analysis)')

    args = parser.parse_args()

    # NEW: Create timestamped output directory
    if args.output:
        base_output = args.output
    else:
        base_output = './processed_data'
    
    if not args.no_timestamp:
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        final_output = f"{base_output}/{timestamp}_results"
    else:
        final_output = base_output
    
    # Handle different modes
    if args.mode == 'replot':
        print("REPLOT MODE: Recreating optimized visualizations and hierarchical clustering from existing coordinates")
        print("=" * 80)
        
        success = run_replot_only(
            output_dir=final_output,
            use_pca=not args.no_pca,
            verbose=args.verbose
        )
        
        if not success:
            sys.exit(1)
            
    elif args.mode == 'full':
        print("FULL PIPELINE MODE: Complete Cell Profiler data processing with Z-score normalization")
        print("=" * 80)
        
        # Validate required arguments for full mode
        if not args.input:
            print("ERROR: --input is required for full pipeline mode")
            parser.print_help()
            sys.exit(1)
        
        # Show the final output directory
        print(f"Output directory: {final_output}")
        if not args.no_timestamp:
            print(f"(Timestamped to prevent overwrites)")
        
        # Create processor with timestamped output
        processor = EnhancedCellPaintingProcessor(
            input_file=args.input,
            metadata_file=args.metadata,
            config_file=args.config,
            output_dir=final_output
        )
        
        # Determine normalization baseline - command line overrides config
        if args.normalization_baseline == 'all-conditions':
            use_all_conditions_baseline = True
            baseline_name = "ALL CONDITIONS"
        elif args.normalization_baseline == 'dmso':
            use_all_conditions_baseline = False  
            baseline_name = "DMSO"
        else:
            # Use config file setting
            from cellprofiler_analyser.io.config_loader import get_normalization_params
            norm_params = get_normalization_params(processor.config)
            config_normalization_type = norm_params.get('normalization_type', 'control_based')
            use_all_conditions_baseline = (config_normalization_type == 'all_conditions')
            
            # Create baseline name for display
            if use_all_conditions_baseline:
                baseline_name = "ALL CONDITIONS"
            else:
                control_compound = norm_params.get('control_compound', 'DMSO')
                baseline_name = f"{control_compound.upper()} CONTROLS"
        
        print(f"Z-score normalization baseline: {baseline_name}")
        if use_all_conditions_baseline:
            print("   Formula: z_score = (value - all_conditions_mean_per_plate) / all_conditions_std_per_plate")
            print("   Result: ALL conditions centered around 0")
        else:
            control_compound = norm_params.get('control_compound', 'DMSO')
            print(f"   Formula: z_score = (value - {control_compound}_mean_per_plate) / {control_compound}_std_per_plate")
            print(f"   Result: {control_compound} controls centered around 0, treatments show deviation from normal")
        
        # Override quality thresholds if provided via command line
        override_any = any([
            args.missing_threshold is not None,
            args.correlation_threshold is not None,
            args.high_var_threshold is not None,
            args.low_var_threshold is not None
        ])
        
        if override_any:
            print("Command-line threshold overrides:")
            processor.set_quality_thresholds(
                missing_threshold=args.missing_threshold,
                correlation_threshold=args.correlation_threshold,
                high_variability_threshold=args.high_var_threshold,
                low_variability_threshold=args.low_var_threshold
            )
        
        # Run pipeline with chosen normalization baseline
        print("Running full Cell Profiler data processing pipeline...")
        print("Using optimized coordinate-based visualization (no legends, compact files)")
        print("Including hierarchical clustering analysis")
        success = processor.run_full_pipeline(
        create_visualizations=True,
        use_all_conditions_baseline=use_all_conditions_baseline,
        run_landmark_analysis=args.run_landmark_analysis,
        run_hierarchical_clustering=args.run_hierarchical_clustering
        )
        
        if success:
            print(f"\nProcessing completed! Results in: {final_output}")
            print("Data files: data/processed_image_data*.parquet")
            print("Visualizations: visualizations/ (OPTIMIZED - small file sizes)")
            print("Interactive plots: visualizations/*/interactive/ (NO LEGENDS)")
            print("Hierarchical clustering: hierarchical_clustering/")
            print("Summary: comprehensive_summary.txt")
            if args.run_landmark_analysis:
                print("Landmark analysis: landmark_analysis/")
                print("  - cellprofiler_landmarks.csv (identified landmarks)")
                print("  - reference_mad_and_dmso.csv (reference quality metrics)")
                print("  - test_mad_and_dmso.csv (test quality metrics)")
                print("  - reference_to_landmark_distances.csv")
                print("  - test_to_landmark_distances.csv")
            print("")
            print("To recreate visualizations with different settings, use:")
            print(f"   python cellprofiler_analyser/main.py --mode replot --output {final_output} --no-timestamp")
            print("")
            print("To try different normalization baselines, use:")
            print(f"   python cellprofiler_analyser/main.py --input {args.input} --output {base_output} --normalization-baseline dmso")
            print(f"   python cellprofiler_analyser/main.py --input {args.input} --output {base_output} --normalization-baseline all-conditions")
            print("")
            print("KEY FEATURES IMPLEMENTED:")
            print("  - Metadata_treatment column creation")
            print("  - Treatment-level aggregation")
            print("  - Hierarchical clustering with Euclidean distance")
            print("  - Coordinate-based plotting from CSV files")
            print("  - No legends displayed (major file size reduction)")
            print("  - Essential metadata hover only (17 key fields)")
            print("  - Compact hover text and optimized layouts")
            print(f"  - Z-score normalization with {baseline_name} baseline")
            print("  - Expected file size reduction: 90-99% vs previous approach")
        else:
            print("ERROR: Processing failed. Check the logs for details.")
            sys.exit(1)

if __name__ == "__main__":
    main()
